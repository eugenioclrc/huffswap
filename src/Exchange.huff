/// @title Exchange ERC20 Liquidity Pool
/// @notice SPDX-License-Identifier: MIT
/// @notice Based on Uniswap V1

#include "huffmate/mechanisms/huff-clones/HuffClone.huff"
#include "huffmate/tokens/ERC20.huff"
#include "huffmate/utils/CommonErrors.huff"
#include "huffmate/utils/ReentrancyGuard.huff"
#include "huffmate/utils/SafeTransferLib.huff"
#include "./ExchangeHelp.huff"
#include "./SwapHelp.huff"

#define function initialize() nonpayable returns ()
#define function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) payable returns (uint256 liquidity_minted)

#define function tokenAddress() view returns (address)
#define function factory() view returns (address)

#define function getTokenToEthInputPrice(uint256) nonpayable returns (uint256)
#define function getEthToTokenInputPrice(uint256) nonpayable returns (uint256)

#define function tokenToEthSwapInput(uint256, uint256, uint256) nonpayable returns (uint256)
#define function ethToTokenSwapInput(uint256, uint256) nonpayable returns (uint256)

#define event Initialized()

#define constant FACTORY_ADDRESS = 0x0000000000000000000000000000000000000000

#define macro TOKEN_ADDRESS() = takes (0) returns (0) {
    0x00 GET_ARG_ADDRESS()  // [arg_addr]
    0x00 mstore             // []
    0x20 0x00 return
}


#define macro FACTORY() = takes (0) returns (0) {
    0x00 [FACTORY_ADDRESS]  // [arg_addr]
    0x00 mstore             // []
    0x20 0x00 return
}

#define macro DECIMALS() = takes (0) returns (0) {
    0x12    // 18
    0x00 mstore             // []
    0x20 0x00 return
}

#define macro INITIALIZE() = takes (0) returns (0) {
    // check caller == factory
    [FACTORY_ADDRESS] caller eq jumpi __callerOk
    ONLY_OWNER(0x00)

    __callerOk:   

    /// @dev removing reentrancy guard, because to make a fair comparission with uni V1
    // UNLOCK()

    __EVENT_HASH(Initialized)                  // []
    0x20 0x00                               // [0, 32, sig]
    log3                                    // []
    stop
}


#define macro ADDLIQUIDITY() = takes (0) returns (0) {
    // require(mgs.value > 0)
    callvalue __callValueOk jumpi 
    ZERO_ASSETS(0x00)
    __callValueOk:

    // require(min_liquidity > 0)
    0x04 calldataload // min_liquidity
    /*
    dup1 __minLiquidityOk jumpi 
    ZERO_ASSETS(0x00)
    __minLiquidityOk:
    */
    
    // require(max_tokens > 0)
    0x24 calldataload // max_tokens
    dup1 __maxTokensOk jumpi 
    ZERO_ASSETS(0x0)
    __maxTokensOk:

    // require(block.timestamp > 0)
    0x44 calldataload // deadline
    timestamp lt __deadlineOk jumpi 
    // write a better revert message 
    0x00 dup1 revert
    __deadlineOk:

    // current stack    [max_tokens, min_liquidity]
    
    /// @dev removing reentrancy guard, because to make a fair comparission with uni V1
    // LOCK()

    0x00 GET_ARG_ADDRESS()
    // current stack    [address, max_tokens, min_liquidity]
    dup2
    // current stack    [max_tokens, address, max_tokens, min_liquidity]
    
    
    [TOTAL_SUPPLY_SLOT] sload
    // [supplylp, max_tokens ,address, max_tokens, min_liquidity]
 
    // Input Stack: [total_supplyLP, max_tokens, address token]
    CALCULATE_TRANSFERS_FOR_LIQUIDITY()

    // [tokens_to_transfer, liquidity_to_mint, address, max_tokens, min_liquidity

    dup1 //  [tokens_to_transfer, tokens_to_transfer, liquidity_to_mint, address, max_tokens, min_liquidity
    swap4 //  [ max_tokens, tokens_to_transfer, liquidity_to_mint, address, tokens_to_transfer, min_liquidity
    0x01 swap1 sub // [ max_tokens-1 , tokens_to_transfer, liquidity_to_mint, address, tokens_to_transfer, min_liquidity
    lt __minTokenTransferOk jumpi 
    0x00 dup1 revert
    __minTokenTransferOk:

    // liquidity_to_mint, address, tokens_to_transfer, min_liquidity
    
    dup1
    // liquidity_to_mint, liquidity_to_mint, address, tokens_to_transfer, min_liquidity
    swap4

    // min_liquidity, liquidity_to_mint, address, tokens_to_transfer, liquidity_to_mint
    // 0x01 swap1 sub    // min_liquidity -1, liquidity_to_mint, address, tokens_to_transfer, liquidity_to_mint
    lt __minSlippeageOk jumpi
        NOT_MINTED(0x00)
    __minSlippeageOk:

    //  address, tokens_to_transfer, liquidity_to_mint
    dup2
    // tokens_to_transfer, address, tokens_to_transfer, liquidity_to_mint

    address
    //  [this, tokens_to_transfer, address, liquidity_to_mint
    caller
    //  [sender,this,tokens_to_transfer, address, liquidity_to_mint

    SAFE_TRANSFER_FROM(0x00)

    //  [tokens_to_transfer, liquidity_to_mint, 
    swap1
    //  [liquidity_to_mint, tokens_to_transfer
    dup1
    //  [liquidity_to_mint, liquidity_to_mint, tokens_to_transfer

    caller dup2 _MINT()
    

    /// @dev removing reentrancy guard, because to make a fair comparission with uni V1
    // UNLOCK()


    // emit AddLiquidity(msg.sender, msg.value, token_amount);
    // __EVENT_HASH(AddLiquidity)                  // []
    // 0x20 0x00                               // [0, 32, sig, from, to]
    // log3                                    // []

    // return  liquidity minted
    dup2
    0x00 mstore             // []
    0x20 0x00 return
}
/*
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    0x20                // [size] - byte size to copy
    0x20 codesize sub   // [offset, size] - offset in the code to copy from
    0x00                // [mem, offset, size] - offset in memory to copy to
    codecopy            // []
    
    // must start locked
    LOCK()
}
*/

#define macro GET_TOKEN_TO_ETH_INPUT_PRICE_WRAPPER() = takes(0) returns(0) {
    0x04 calldataload                 // [tokensSold]
    0x00 GET_ARG_ADDRESS()            // [tokenAddress, tokensSold]

    GET_TOKEN_TO_ETH_INPUT_PRICE()    // [price]
    
    0x00                              // [0x00, price]
    mstore                            

    0x20    
    0x00
    return
}

#define macro GET_ETH_TO_TOKEN_INPUT_PRICE_WRAPPER() = takes(0) returns(0) {
    0x04 calldataload                 // [ethSold]
    0x00 GET_ARG_ADDRESS()            // [tokenAddress, ethSold]

    GET_ETH_TO_TOKEN_INPUT_PRICE()    // [price]
    
    0x00                              // [0x00, price]
    mstore                            

    0x20    
    0x00
    return
}

#define macro TOKEN_TO_ETH_SWAP_INPUT_WRAPPER() = takes(0) returns(0) {
    caller                      // [tokenRecipient]
    0x00 GET_ARG_ADDRESS()      // [minEth, tokenAddress, tokenRecipient]
    0x24 calldataload           // [minEth, tokenAddress, tokenRecipient]
    0x04 calldataload           // [tokensSold, minEth, tokenAddress, tokenRecipient]
    0x44 calldataload           // [deadline, tokensSold, minEth, tokenAddress, tokenRecipient]

    TOKEN_TO_ETH_SWAP_INPUT()   // [ethBought]

    0x00                        
    mstore

    0x20
    0x00
    return
}
        
#define macro TOKEN_TO_ETH_SWAP_INPUT_RECIPIENT_WRAPPER() = takes(0) returns(0) {
    0x64 calldataload           // [tokenRecipient]
    0x00 GET_ARG_ADDRESS()      // [tokenAddress, tokenRecipient]
    0x24 calldataload           // [minEth, tokenAddress, tokenRecipient]
    0x04 calldataload           // [tokensSold, minEth, tokenAddress, tokenRecipient]
    0x44 calldataload           // [deadline, tokensSold, minEth, tokenAddress, tokenRecipient]

    TOKEN_TO_ETH_SWAP_INPUT()   // [ethBought]

    0x00                        
    mstore

    0x20
    0x00
    return
}
  
#define macro ETH_TO_TOKEN_SWAP_INPUT_WRAPPER() = takes(0) returns(0) {
    0x00 GET_ARG_ADDRESS()      // [tokenAddress]
    caller                      // [recipient, tokenAddress]
    0x04 calldataload           // [minTokens, recipient, tokenAddress]
    0x24 calldataload           // [deadline, minTokens, recipient, tokenAddress]

    ETH_TO_TOKEN_SWAP_INPUT()   // [ethBought]

    0x00                        
    mstore

    0x20
    0x00
    return
}

#define macro ETH_TO_TOKEN_SWAP_INPUT_RECIPIENT_WRAPPER() = takes(0) returns(0) {
    0x00 GET_ARG_ADDRESS()      // [tokenAddress]
    0x44 calldataload           // [recipient, tokenAddress]
    0x04 calldataload           // [minTokens, recipient, tokenAddress]
    0x24 calldataload           // [deadline, minTokens, recipient, tokenAddress]

    ETH_TO_TOKEN_SWAP_INPUT()   // [ethBought]

    0x00                        
    mstore

    0x20
    0x00
    return
}

#define macro MAIN() = takes (0) returns (0) {
    pc calldataload 0xE0 shr
    dup1 __FUNC_SIG(addLiquidity) eq addLiquidityJump jumpi
    dup1 __FUNC_SIG(tokenAddress) eq tokenAddress jumpi
    dup1 __FUNC_SIG(factory) eq factory jumpi

    dup1 __FUNC_SIG(getTokenToEthInputPrice) eq getTokenToEthInputPriceJump jumpi
    dup1 __FUNC_SIG(getEthToTokenInputPrice) eq getEthToTokenInputPriceJump jumpi
    
    dup1 __FUNC_SIG("tokenToEthSwapInput(uint256,uint256,uint256,address)") eq tokenToEthSwapInputRecipientJump jumpi
    dup1 __FUNC_SIG(tokenToEthSwapInput) eq tokenToEthSwapInputJump jumpi

    dup1 __FUNC_SIG("ethToTokenSwapInput(uint256,uint256,address)") eq ethToTokenSwapInputRecipientJump jumpi
    dup1 __FUNC_SIG(ethToTokenSwapInput) eq ethToTokenSwapInputJump jumpi


    dup1 __FUNC_SIG(decimals) eq decimalsJump jumpi
    //dup1 __FUNC_SIG(DOMAIN_SEPARATOR) eq domainSeparatorJump jumpi

   

    ERC20_MAIN()


    dup1 __FUNC_SIG(initialize) eq initializeJump jumpi

    // Revert if no selector matches
    0x00 dup1 revert

    tokenAddress:
        TOKEN_ADDRESS()

    factory:
        FACTORY()

    decimalsJump:
        DECIMALS()

    initializeJump:
        INITIALIZE()

    addLiquidityJump:
        ADDLIQUIDITY()

    getTokenToEthInputPriceJump:
        GET_TOKEN_TO_ETH_INPUT_PRICE_WRAPPER() 

    getEthToTokenInputPriceJump:
        GET_ETH_TO_TOKEN_INPUT_PRICE_WRAPPER()

    tokenToEthSwapInputJump:
        TOKEN_TO_ETH_SWAP_INPUT_WRAPPER()

    tokenToEthSwapInputRecipientJump:
        TOKEN_TO_ETH_SWAP_INPUT_RECIPIENT_WRAPPER()

    ethToTokenSwapInputJump:
        ETH_TO_TOKEN_SWAP_INPUT_WRAPPER()

    ethToTokenSwapInputRecipientJump:
        ETH_TO_TOKEN_SWAP_INPUT_RECIPIENT_WRAPPER()
}
