#include "huffmate/utils/CommonErrors.huff"

#define function balanceOf(address) view returns (uint256)

#define error ErrDeadlineExpired(uint256)
#define error ErrEthOutput(uint256, uint256)

#define event EthPurchase(address indexed buyer, address recipient, uint256 tokens_sold, uint256 eth_bought)

#define macro ETH_TO_TOKEN_SWAP_INPUT() = takes(4) returns(1) {
  pop
  pop
  pop
  pop
  0x20
}

#define macro TOKEN_TO_ETH_SWAP_INPUT() = takes(5) returns(0) {
  // Input Stack:   [deadline, tokensSold, minEth, tokenAddress, tokenRecipient]
  // Output Stack:  [ethBought]

  // deadline >= block.timestamp
  VALIDATE_DEADLINE()     // [tokensSold, minEth, tokenAddress, tokenRecipient]

  // tokensSold != 0
  dup1                    // [tokensSold, tokensSold, minEth, tokenAddress, tokenRecipient]
  IS_NOT_ZERO()           // [tokensSold, minEth, tokenAddress, tokenRecipient]


  // minEth != 0
  dup2                    // [minEth, tokensSold, minEth, tokenAddress, tokenRecipient]
  IS_NOT_ZERO()           // [tokensSold, minEth, tokenAddress, tokenRecipient]

   

  dup3                    // [tokenAddress, tokensSold, minEth, tokenAddress, tokenRecipient]
  address                 // [self, tokenAddress, tokensSold, minEth, tokenAddress, tokenRecipient]

  GET_TOKEN_BALANCE_OF_STATIC()   // [tokenReserve, tokensSold, minEth, tokenAddress, tokenRecipient]

  selfbalance               // [balance, tokenReserve, tokensSold, minEth, tokenAddress, tokenRecipient]

  swap1                     // [tokenReserve, balance, tokensSold, minEth, tokenAddress, tokenRecipient]
  swap3                     // [tokensSold, balance, tokenReserve, minEth, tokenAddress, tokenRecipient]
  
  // todo: getting the wrong value
  GET_INPUT_PRICE()         // [ethBought, minEth, tokenAddress, tokenRecipient]

  dup3                      // [minEth, ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]
  dup2                      // [ethBought, minEth, ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]
  VALIDATE_ETH_RECEIVE()    // [ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]

  dup4                      // [tokenAddress, ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]
  dup3                      // [tokensSold, tokenAddress, ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]
  address                   // [selfAddress, tokensSold, tokenAddress, ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]
  caller                    // [caller, selfAddress, tokensSold, tokenAddress, ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]
  TRANSFER_FROM_CALL()      // [ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]

  dup1                      // [ethBought, ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]
  dup6                      // [tokenRecipient, ethBought, ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]
  SEND_ETHER()              // [ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]
 
  dup1                      // [ethBought, ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]

  // save ethBought in memory
  0x40
  mstore              // [ethBought, tokensSold, minEth, tokenAddress, tokenRecipient]

  // save tokensSold in memory
  swap1
  0x20
  mstore              // [ethBought, minEth, tokenAddress, tokenRecipient]

  // save tokenRecipient
  swap4               // [tokenRecipient,  minEth, tokenAddress,  ethBought]
  0x00
  mstore              // [minEth, tokenAddress, ethBought]

  caller              // [caller, minEth, tokenAddress, ethBought]
  
  __EVENT_HASH(EthPurchase) // [event_hash, caller, minEth, tokenAddress, ethBought]
  0x00
  0x40
  log2            // [minEth, tokenAddress, ethBought]

  pop
  pop
}

#define macro SEND_ETHER() = takes(2) returns(0) {
  // Input Stack:  [to, amount]
  // Output Stack: []

  0x20      // [retSize, to, amount]
  0x00      // [retOffset, retSize, to, amount]
  0x00      // [argsSize, retOffset, retSize, to, amount]
  0x00      // [argsOffset, argsSize, retOffset, retSize, to, amount]  
  
  dup6      // [amount, argsOffset, argsSize, retOffset, retSize, to, amount]  
  dup6      // [to, amount, argsOffset, argsSize, retOffset, retSize, to, amount]  

  gas       // [gas, to, amount, argsOffset, argsSize, retOffset, retSize, to, amount]  
  
  call      // [success, to, amount]

  // Revert if call is unsuccessful
  iszero iszero _success jumpi
  0x00 dup1 revert
  
  _success:             // [to, amount]
    pop
    pop // clean stack
}

#define macro VALIDATE_ETH_RECEIVE() = takes(2) returns(0) {
  // Input Stack:  [ethBought, minEth]
  // Output Stack: []

  dup2          // [ethBought, minEth]
  dup2          // [ethBought, minEth, ethBought, minEth]
  gt            // [greaterThanMinEth, ethBought, minEth]
  dup2          // [ethBought, greaterThanMinEth, ethBought, minEth] 
  dup3          // [minEth, ethBought, greaterThanMinEth, ethBought, minEth] 
  eq            // [equalThanMinEth, greaterThanMinEth, ethBough, minEth]
  or            // [validAmount, ethBough, minEth]]
  _continue
  jumpi
  
  __ERROR(ErrEthOutput)     // [signature, ethBough, minEth]
  0x00
  mstore                    // [ethBough, minEth]

  0x04
  mstore                    // [minEth]
  
  0x24                        
  mstore                    // []

  0x44
  0x00
  revert

  _continue: // [ethBough, minEth]
    pop
    pop // clean stack
}

#define macro VALIDATE_DEADLINE() = takes(1) returns(0) {
  // Input Stack:  [deadline]
  // Output Stack: []

  dup1                              // [deadline, deadline]
  timestamp                         // [timestamp, deadline, deadline]
  lt                                // [timestampLessThanDeadline, deadline]

  swap1                             // [deadline, timestampLessThanDeadLine]
  timestamp                         // [timestamp, deadline, timestampLessThanDeadLine]
  eq                                // [timestampEqualThanDeadLine, timestampLessThanDeadLine]
  or                                // [validDeadLine]

  _continue
  jumpi

  // throw error
  __ERROR(ErrDeadlineExpired)       // [signature, deadline]
  0x00 
  mstore                            // [deadline]
  0x04
  mstore                            // []
  
  0x24
  0x00
  revert

  _continue:
}

#define macro GET_INPUT_PRICE() = takes(3) returns(1) {
  // Input Stack:  [output_reserve, input_reserve, input_amount]
  // Output Stack: [price]

  0x3E5         // [997, output_reserve, input_reserve, input_amount]
  dup4          // [input_amount, 997, output_reserve, input_reserve, input_amount]
  mul           // [input_amount_with_fee, output_reserve, input_reserve, input_amount]
  dup1          // [input_amount_with_fee, input_amount_with_fee, output_reserve, input_reserve, input_amount]
  swap2         // [output_reserve, input_amount_with_fee, input_amount_with_fee, input_reserve, input_amount]
  mul           // [numerator, input_amount_with_fee, input_reserve, input_amount]
  dup3          // [input_reserve, numerator, input_amount_with_fee, input_reserve, input_amount]
  0x3E8         // [1000, input_reserve, numerator, input_amount_with_fee, input_reserve, input_amount]
  mul           // [input_reserve_x_1000, numerator, input_amount_with_fee, input_reserve, input_amount]
  dup3          // [input_amount_with_fee, input_reserve_x_1000, numerator, input_amount_with_fee, input_reserve, input_amount]
  add           // [denominator, numerator, input_amount_with_fee, input_reserve, input_amount]
  swap1         // [numerator, denominator]
  div           // [price]
}

#define macro GET_TOKEN_TO_ETH_INPUT_PRICE() = takes(2) returns(1) {
    // Input Stack:    [tokenAddress, tokensSold]
    // Output Stack:   [price]  

    dup1
    IS_NOT_ADDRESS_ZERO()

    address       // [fromAddress, tokenAddress, tokenSold]
    GET_TOKEN_BALANCE_OF_STATIC()   // [totalReserve, tokenSold]

    selfbalance         // [balance, totalReserve, tokensSold]

    GET_INPUT_PRICE()   // [price]
}

#define macro GET_ETH_TO_TOKEN_INPUT_PRICE() = takes(2) returns(1) {
    // Input Stack:    [tokenAddress, ethSold]
    // Output Stack:   [price]  

    // ethSold != 0
    dup2
    IS_NOT_ZERO()

    address       // [fromAddress, tokenAddress, ethSold]
    GET_TOKEN_BALANCE_OF_STATIC()   // [totalReserve, ethSold]

    // totalReserve != 0
    dup1 
    IS_NOT_ZERO()

    selfbalance         // [balance, totalReserve, ethSold]

    swap1

    GET_INPUT_PRICE()   // [price]
}

#define macro IS_NOT_ZERO() = takes(1) returns(0) {
  // Input Stack: [value]
  // Output Stack: []

  iszero        // [is_zero]
  not           // [is_not_zero]
  _continue   
  jumpi
  ZERO_ASSETS(0x00)

  _continue:
}

#define macro IS_NOT_ADDRESS_ZERO() = takes(1) returns(0) {
  // Input Stack: [address]
  // Output Stack: []

  0x00          // [0x00, address]
  eq            // [is_address(0)]
  not           // [is_not_address(0)]
  _continue 
  jumpi
  ZERO_ADDRESS(0x00)

  _continue:
}

#define macro GET_TOKEN_BALANCE_OF_STATIC() = takes(2) returns(1) {
  // Input Stack:  [fromAddress, tokenAddress]
  // Output Stack: [balance]

  // save signature on memory
  __FUNC_SIG(balanceOf) // [signature, fromAddress, tokenAddress]
  0xE0 shl
  0x00 mstore // [fromAddress, tokenAddress]      

  // save fromAddress in memory
  0x04        // [0x04, fromAddress, tokenAddress]
  mstore      // [tokenAddress]

  0x20      // [retSize, tokenAddress]
  0x00      // [retOffset, retSize, tokenAddress]
  0x24      // [argsSize, retOffset, retSize, tokenAddress]
  0x00      // [argsOffset, argsSize, retOffset, retSize, tokenAddress]  
  
  dup5      // [tokenAddress, argsOffset, argsSize, retOffset, retSize, tokenAddress]  
  
  gas       // [gas, tokenAddress, argsOffset, argsSize, retOffset, retSize, tokenAddress]  
  
  staticcall  // [success, tokenAddress]

  // Revert if call is unsuccessful
  iszero iszero _success jumpi
  0x00 dup1 revert
  
  _success:             // [tokenAddress]
    pop
    0x00
    mload               // [balance] 
}

#define macro TRANSFER_FROM_CALL() = takes(4) returns(1) {
    // Input Stack:  [from, to, amount, tokenAddress]
    // Output Stack: []

    // save function signature
    __FUNC_SIG(transferFrom)
    0xE0 shl
    0x00 mstore

    // from
    0x04
    mstore

    // to
    0x24
    mstore

    // amount
    0x44
    mstore

    0x20      // [retSize, tokenAddress]
    0x00      // [retOffset, retSize, tokenAddress]
    0x64      // [argsSize, retOffset, retSize, tokenAddress]
    0x00      // [argsOffset, argsSize, retOffset, retSize, tokenAddress]  
    
    0x00      // [callvalue, argsOffset, argsSize, retOffset, retSize, tokenAddress]  

    dup6      // [tokenAddress, callvalue, argsOffset, argsSize, retOffset, retSize, tokenAddress]  
    
    gas       // [gas, tokenAddress, callvalue, argsOffset, argsSize, retOffset, retSize, tokenAddress]  
    
    call      // [success, tokenAddress]

    // Revert if call is unsuccessful
    iszero iszero _success jumpi
    0x00 dup1 revert

    _success:  // []
      pop   // clean stack
}

#define macro SAFE_TRANSFER_FROM() = takes(4) returns(1) {
    // Input Stack:  [from, to, amount, tokenAddress]
    // Output Stack: []

    // save function signature
    __FUNC_SIG(transferFrom)
    0xE0 shl
    0x00 mstore

    // from
    0x04
    mstore

    // to
    0x24
    mstore

    // amount
    0x44
    mstore

    0x20      // [retSize, tokenAddress]
    0x00      // [retOffset, retSize, tokenAddress]
    0x64      // [argsSize, retOffset, retSize, tokenAddress]
    0x00      // [argsOffset, argsSize, retOffset, retSize, tokenAddress]  
    
    0x00      // [callvalue, argsOffset, argsSize, retOffset, retSize, tokenAddress]  

    dup6      // [tokenAddress, callvalue, argsOffset, argsSize, retOffset, retSize, tokenAddress]  
    
    gas       // [gas, tokenAddress, callvalue, argsOffset, argsSize, retOffset, retSize, tokenAddress]  
    
    call      // [success, tokenAddress]

    // Revert if call is unsuccessful
    iszero iszero _success jumpi
    0x00 dup1 revert
    
    _success:             // []
      pop
      0x00
      mload               // [success]

      iszero              // [successIsFalse]
      not                 // [successIsNotFalse]
      
      returndatasize      // [returnDataSize, successIsNotFalse]
      iszero              // [returnDataSizeIsZero, successIsNotFalse]
      or                  // [transferFailed]
      iszero              // [transferHasNotFailed]
      _finish
      jumpi

      

      _finish:
}