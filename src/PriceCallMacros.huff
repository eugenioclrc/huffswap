#include "huffmate/utils/CommonErrors.huff"
#include "huffmate/tokens/ERC20.huff"

// #define function balanceOf(address) view returns (uint256)

#define macro GET_INPUT_PRICE() = takes(3) returns(1) {
  // input    [output_reserve, input_reserve, input_amount]
  // output   [price]

  0x3E5         // [997, output_reserve, input_reserve, input_amount]
  dup4          // [input_amount, 997, output_reserve, input_reserve, input_amount]
  mul           // [input_amount_with_fee, output_reserve, input_reserve, input_amount]
  dup1          // [input_amount_with_fee, input_amount_with_fee, output_reserve, input_reserve, input_amount]
  swap2         // [output_reserve, input_amount_with_fee, input_amount_with_fee, input_reserve, input_amount]
  mul           // [numerator, input_amount_with_fee, input_reserve, input_amount]
  dup3          // [input_reserve, numerator, input_amount_with_fee, input_reserve, input_amount]
  0x3E8         // [1000, input_reserve, numerator, input_amount_with_fee, input_reserve, input_amount]
  mul           // [input_reserve_x_1000, numerator, input_amount_with_fee, input_reserve, input_amount]
  dup3          // [input_amount_with_fee, input_reserve_x_1000, numerator, input_amount_with_fee, input_reserve, input_amount]
  add           // [denominator, numerator, input_amount_with_fee, input_reserve, input_amount]
  swap1         // [numerator, denominator]
  div           // [price]
}

#define macro GET_TOKEN_TO_ETH_INPUT_PRICE() = takes(2) returns(1) {
    // input      [tokenAddress, tokensSold]
    // output     [price]  

    dup1
    IS_NOT_ADDRESS_ZERO()

    address       // [fromAddress, tokenAddress, tokenSold]
    GET_TOKEN_BALANCE_OF_STATIC()   // [totalReserve, tokenSold]

    selfbalance         // [balance, totalReserve, tokensSold]

    GET_INPUT_PRICE()   // [price]
}

#define macro GET_ETH_TO_TOKEN_INPUT_PRICE() = takes(2) returns(1) {
    // input      [tokenAddress, ethSold]
    // output     [price]  

    // ethSold != 0
    dup2
    IS_NOT_ZERO()

    address       // [fromAddress, tokenAddress, ethSold]
    GET_TOKEN_BALANCE_OF_STATIC()   // [totalReserve, ethSold]

    // totalReserve != 0
    dup1 
    IS_NOT_ZERO()

    selfbalance         // [balance, totalReserve, ethSold]

    swap1

    GET_INPUT_PRICE()   // [price]
}

#define macro IS_NOT_ZERO() = takes(1) returns(0) {
  // Input Stack: [value]
  // Output Stack: []

  iszero        // [is_zero]
  not           // [is_not_zero]
  _continue   
  jumpi
  ZERO_ASSETS(0x00)

  _continue:
}

#define macro IS_NOT_ADDRESS_ZERO() = takes(1) returns(0) {
  // Input Stack: [address]
  // Output Stack: []

  0x00          // [0x00, address]
  eq            // [is_address(0)]
  not           // [is_not_address(0)]
  _continue 
  jumpi
  ZERO_ADDRESS(0x00)

  _continue:
}

#define macro GET_TOKEN_BALANCE_OF_STATIC() = takes(2) returns(1) {
  // Input Stack:  [fromAddress, tokenAddress]
  // Output Stack: [balance]

  // save signature on memory
  __FUNC_SIG(balanceOf) // [signature, fromAddress, tokenAddress]
  0xE0 shl
  0x00 mstore // [fromAddress, tokenAddress]      

  // save fromAddress in memory
  0x04        // [0x04, fromAddress, tokenAddress]
  mstore      // [tokenAddress]

  0x20      // [retSize, tokenAddress]
  0x00      // [retOffset, retSize, tokenAddress]
  0x24      // [argsSize, retOffset, retSize, tokenAddress]
  0x00      // [argsOffset, argsSize, retOffset, retSize, tokenAddress]  
  
  dup5      // [tokenAddress, argsOffset, argsSize, retOffset, retSize, tokenAddress]  
  
  gas       // [gas, tokenAddress, argsOffset, argsSize, retOffset, retSize, tokenAddress]  
  
  staticcall  // [success, tokenAddress]

  // Revert if call is unsuccessful
  iszero iszero _success jumpi
  0x00 dup1 revert
  
  _success:             // [tokenAddress]
    pop
    0x00
    mload               // [balance, tokenAddress] 
}