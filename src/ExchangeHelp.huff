#include "huffmate/tokens/ERC20.huff"

#define macro TOTAL_ASSETS_INNER() = takes (1) returns (1) {
    // Input Stack: [token_address]
    // Output Stack: [total_assets]

    // Store the asset.balanceOf(address(this)) args in memory
    __FUNC_SIG(balanceOf)
    0xE0 shl
    0x20 mstore
    address 0x24 mstore

    // Get the asset variable is stack in this point
    // [token_address]

    // Construct the call
    0x20                            // [retSize, asset]
    0x00                            // [retOffset, retSize, asset]
    0x24                            // [argSize, retOffset, retSize, asset]
    0x20                            // [argOffset, argSize, retOffset, retSize, asset]
    0x00                            // [value, argOffset, argSize, retOffset, retSize, asset]
    dup6                            // [to, value, argOffset, argSize, retOffset, retSize, asset]
    gas                             // [gas, to, value, argOffset, argSize, retOffset, retSize, asset]
    call                            // [success, asset]

    // Verify the call succeeded
    iszero iszero success jumpi     // [asset]
    0x00 dup1 revert                // []
    success:

    // Since the returndata is copied to [0x00:0x20], we can just mload
    pop 0x00 mload                  // [total_assets]
}

#define macro CALCULATE_TRANSFERS_FOR_LIQUIDITY() = takes (3) returns (2) {
    // Input Stack: [total_supplyLP, max_tokens, address token]
    // Output Stack: [tokens_to_transfer, liquidity_to_mint]
    dup1 __notFirstAdd jumpi   
    
    callvalue // [value, total_supplyLP, max_tokens, address token]
    dup3      // [max_tokens = tokens to transfer, value = liquidity to mint]
    // return [max_tokens, eth_balance]
    __end jump
    
    
    __notFirstAdd:
    
    // [total_supplyLP, max_tokens, address token]

    // uint256 eth_reserve = address(this).balance - msg.value;
    callvalue address balance sub 

    // [eth_reserve, total_supplyLP, max_tokens, address token]

    // uint256 token_reserve = ERC20(tokenAddress).balanceOf(address(this));
    dup4
    TOTAL_ASSETS_INNER()

    // [token_reserve, eth_reserve, total_supplyLP, max_tokens]

    // token_amount = msg.value * token_reserve / eth_reserve;
    callvalue mul
    // [token_reserve * msg.value, eth_reserve, total_supplyLP, max_tokens]
    
    dup2 swap1 div 
    // [token_amount_effective, eth_reserve, total_supplyLP, max_tokens]
    //__end jump
    // liquidity_minted = msg.value * total_supplyLP / eth_reserve;
    dup3

    // [total_supplyLP, token_amount_effective, eth_reserve, max_tokens] 
    callvalue mul

    // [total_supplyLP * msg.value, token_amount, eth_reserve, max_tokens] 
    dup3 swap1 div
    // [total_supplyLP * msg.value/ eth_reserve, token_amount, eth_reserve, max_tokens] 
    swap1
    // [liquidityTo mint, token_amount, eth_reserve, total_supplyLP, max_tokens]

    __end:
}